# 도메인 객체의 생명주기

## AGGREGATE

---

> 애그리거트는 모든 DDD 의 전술적인 지침중에서도 무엇보다 정확히 규명되지 않은 패턴 중 하나이다.

![img_1.png](img_1.png)

```java
public class Product {
    ...
    
    public void planBacklogItem(String aSummary, String aCategory
            , BacklogItemType aType, StoryPoints aStoryPoints) {
        ...
    }
    ...
}
```
여기선 모든 메소드가 CQS 커맨드다. 즉 이는 새로운 컴포넌트를 컬렉션에 추가해 Product 의 상태를 수정하는데 이에 따라 void 반환 타입을 갖게 된다.
그러나 여러 애그리거트로 나눈 설계에선 다음과 같은 형태를 갖게 된다.

<small> > Command 는 결과를 반환하지는 않지만 시스템의 상태를 변경시킨다. Command 함수는 부주의하게 실행하는 경우 사이드 이펙트가 발생할 수 있기 때문에 함수간 사용 순서를 고민해야 한다.</small>

```java
public class Product {
    ...
    
    public BacklogItem planBacklogItem(String aSummary, String aCategory
            , BacklogItemType aType, StoryPoints aStoryPoints) {
        ...
    }
    ...
}
```
이와 같이 새롭게 설계된 메소드는 CQS 쿼리 계약을 맺고 있으며 팩토리로서 동작한다. <Strong> 즉 각 메소드는 새로운 애그리거트 인스턴스를 생성해서 그 참조를 반환한다.</Strong>

<small> > Query 는 결과값을 반환할 뿐 관찰 가능한 시스템의 상태를 변화시키지 않는다. 따라서 사이드 이펙트가 없다. </small>


<br>


####  CQS(Command Query Separation)
> CQS는 함수가 가급적 Command 와 Query 중 한 가지 역할만을 해야한다는 원칙이다. 질의를 수행하는 함수가 시스템의 상태를 변경시키는 등 부수 효과를 유발하면 예측 불가능한 버그가 발생하기 쉽다. CQS 준수를 통해 부수 효과가 존재하는 명령형 언어에서 부수 효과가 없는 함수형 언어의 장점을 제한적으로 누릴 수 있게 된다.


<br>

### 규칙: 진짜 고정자를 일관성 경계 안에 모델링하라

---

바운디드 컨텍스트에서 애그리거트를 찾으려면 모델의 진짜 고정자를 이해해야 한다. 이를 알아야만 주어진 애그리거트로 묶어야 할 객체가 무엇인지 결정 할 수 있다.
고정자는 언제나 일관성을 유지해야 한다는 비즈니스 규칙이다. 

#### 일관성
+ <Strong> 트랜잭션적 일관성: 즉각적이고 원자적이라 간주된다.</Strong>
+ 결과적 일관성: N개 이상의 같은 값을 반환해야 사용자에게 보여준다.


한 트랜잭션 당 애그리거트 인스턴스를 수정하도록 제한한다. 이는 애그리거트를 사용하는 가장 중요한 이유이다.



<br>

### 규칙: 작은 애그리거트로 설계하라

---

+ 엔터티보단 값 객체를 활용함으로써 엔터티


<br>

## REPOSITORY

---
