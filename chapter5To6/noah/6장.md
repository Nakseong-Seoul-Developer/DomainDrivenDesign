# 도메인 객체의 생명주기
> 모든 객체에는 생명주기가 있다. 어떤 객체는 단순하고 일시적으로 사용된 후 가비지 컬렉터에 보내지며 이런 객체는 복잡하게 만들 필요가 없다. 그러나 또 다른 어떤 객체들은 복잡한 상호의존성을 맺으며 여러 가지의 상태 변화를 겪기도 하는데, 이때 갖가지 불변식이 적용된다. 

## AGGREGATE

---

> 애그리거트는 모든 DDD 의 전술적인 지침중에서도 무엇보다 정확히 규명되지 않은 패턴 중 하나이며, 우리가 데이터 변경의 단위로 다루는 연관 객체의 묶음을 말한다.

> 각 애그리거트에는 루트와 경계가 존재한다. 경계는 애그리거트에 무엇이 포함되고 포함되지 않는지를 정의하며, 루트는 특정 엔티티를 가르키며 단 하나만 존재한다.

![img_1.png](img_1.png)

```java
public class Product {
    ...
    
    public void planBacklogItem(String aSummary, String aCategory
            , BacklogItemType aType, StoryPoints aStoryPoints) {
        ...
    }
    ...
}
```
여기선 모든 메소드가 CQS 커맨드다. 즉 이는 새로운 컴포넌트를 컬렉션에 추가해 Product 의 상태를 수정하는데 이에 따라 void 반환 타입을 갖게 된다.
그러나 여러 애그리거트로 나눈 설계에선 다음과 같은 형태를 갖게 된다.

<small> > Command 는 결과를 반환하지는 않지만 시스템의 상태를 변경시킨다. Command 함수는 부주의하게 실행하는 경우 사이드 이펙트가 발생할 수 있기 때문에 함수간 사용 순서를 고민해야 한다.</small>

```java
public class Product {
    ...
    
    public BacklogItem planBacklogItem(String aSummary, String aCategory
            , BacklogItemType aType, StoryPoints aStoryPoints) {
        ...
    }
    ...
}
```
이와 같이 새롭게 설계된 메소드는 CQS 쿼리 계약을 맺고 있으며 팩토리로서 동작한다. <Strong> 즉 각 메소드는 새로운 애그리거트 인스턴스를 생성해서 그 참조를 반환한다.</Strong>

<small> > Query 는 결과값을 반환할 뿐 관찰 가능한 시스템의 상태를 변화시키지 않는다. 따라서 사이드 이펙트가 없다. </small>


<br>


####  CQS(Command Query Separation)
> CQS는 함수가 가급적 Command 와 Query 중 한 가지 역할만을 해야한다는 원칙이다. 질의를 수행하는 함수가 시스템의 상태를 변경시키는 등 부수 효과를 유발하면 예측 불가능한 버그가 발생하기 쉽다. CQS 준수를 통해 부수 효과가 존재하는 명령형 언어에서 부수 효과가 없는 함수형 언어의 장점을 제한적으로 누릴 수 있게 된다.


<br>

### 규칙: 진짜 고정자를 일관성 경계 안에 모델링하라

---

바운디드 컨텍스트에서 애그리거트를 찾으려면 모델의 진짜 고정자를 이해해야 한다. 이를 알아야만 주어진 애그리거트로 묶어야 할 객체가 무엇인지 결정 할 수 있다.
고정자는 언제나 일관성을 유지해야 한다는 비즈니스 규칙이다. 

#### 일관성
+ <Strong> 트랜잭션적 일관성: 즉각적이고 원자적이라 간주된다.</Strong>
+ 결과적 일관성: N개 이상의 같은 값을 반환해야 사용자에게 보여준다.


한 트랜잭션 당 애그리거트 인스턴스를 수정하도록 제한한다. 이는 애그리거트를 사용하는 가장 중요한 이유이다.



<br>

### 규칙: 작은 애그리거트로 설계하라

---

+ 엔터티보단 값 객체를 활용한다.


<br>

## FACTORY
> 어떤 객체나 전체 애그리거트를 생성하는 일이 복잡해지거나 내부 구조를 너무 많이 드러내는 경우 팩토리가 캡슐화를 제공해준다.

> 복잡한 복합 객체를 조립하는 일(팩토리가 하는 일)은 조립이 완료됐을 떄 해당 객체가 하는 일과(도메인적인 일?)과 가장 관련성이 적은 일이다.
> 클라이언트가 응용 계층 일부를 구성하고 있다면 도메인 계층에서 책임이 새어 나온다는 것이다.

#### 팩토리를 잘 설계하기 위한 규칙
+ 각 생성 방법은 원자적이어야 하며, 생성된 객체나 애그리거트의 불변식을 모두 지켜야 한다. 
+ 팩토리는 일관성 있는 상태에서만 객체를 만들어 낼 수 있어야 한다. 엔티티의 경우 이것은 전체 애그리거트를 생성하는 것을 의미하며, 이때 모든 불변식을 충족하고 선택적인 요소도 추가될 것이다. 
+ VO의 경우에는 모든 속성이 올바른 최종 상태로 초기화된다는 것을 의미한다.
+ 인터페이스를 통해 올바르게 생성할 수 없는 객체를 요청할 수 있다면 예외를 던지거나 적절하지 않은 값을 반환하도록 보장한다. 
+ 팩토리는 생성된 클래스보다 생성하고자 하는 타입으로 추상화돼야 한다.

#### 팩토리와 팩토리 위치 선정
+ 애그리거트의 루트에 팩토리 메소드를 만들 수 있다. 
    + 한 요소가 추가될 때 애그리거트의 무결성을 보장하는 책임을 루트가 담당하고, 동시에 모든 외부 클라이언트에게서 애그리거트의 내부 구현을 감출 수 있다.
+ 밀접한 관련이 있는 특정 객체에 만들 수 있다.
    + 데이터나 규칙이 많은 객체를 생성할 때 해당 객체의 생성 정보를 필요로 하는 것을 주일 수 있다.
    
#### 생성자만으로 충분한 경우
+ 다형성을 활용하지 않는 간단한 객체를 이해하기 어렵게 만들 수 있다.

#### 인터페이스 설계
+ 각 연산은 원자적이어야 한다.
  + 복잡한 객체를 만들어내는데 필요한 것들을 모두 한 번에 전달해야 한다.
  + 생성이 실패해서 특정 불변식이 충족되지 못하는 상황에서는 예외나 널을 반환할 수 있다.  
+ 팩토리는 자신에게 전달된 인자와 결합될 것이다.

## REPOSITORY

---
